<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BTTS + Over 2.5 + 1X2 + Cantos — Campo Único (mín. 10, sem limite)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { color-scheme: dark light; }
    .badge { @apply inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium; }
    .meter { @apply h-2 rounded-full overflow-hidden bg-zinc-800 border border-zinc-700; }
    .meter > div { height: 100%; }
  </style>
</head>
<body class="bg-zinc-950 text-zinc-100 min-h-screen">

  <div class="max-w-6xl mx-auto p-6 space-y-6 pt-20">
    <header class="flex items-start justify-between gap-4">
      <div>
        <h1 class="text-2xl md:text-3xl font-bold">Analisador — BTTS + Over 2.5 + 1X2 + Cantos</h1>
        <p class="text-zinc-400 mt-1">
          Cole blocos <em>“Jogos Anteriores: &lt;time&gt;”</em>. Usa <strong>mínimo 10</strong> jogos e aceita <strong>qualquer quantidade acima</strong> (sem limite), misturando casa/fora no geral. Extrai <span class="text-emerald-300 font-semibold">escanteios FT</span>. <span class="text-zinc-300">Sem H2H.</span>
        </p>
      </div>
    </header>

    <section class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4 space-y-3">
      <h2 class="font-semibold">Entrada — <span class="text-emerald-300">Geral (colar bruto)</span></h2>
      <textarea id="taUnified" rows="10" placeholder="Cole aqui o conteúdo bruto (com 'Jogos Anteriores: Palmeiras' / 'Jogos Anteriores: Juventude' etc.)." class="w-full bg-zinc-950 border border-zinc-800 rounded-xl p-3 text-sm"></textarea>
    </section>

    <div class="flex items-center gap-3 flex-wrap">
      <button id="btnAnalyze" class="px-4 py-2 rounded-xl bg-white text-black font-semibold hover:opacity-90 transition">Analisar</button>
      <button id="btnClear" class="px-4 py-2 rounded-xl bg-zinc-800 text-zinc-100 hover:bg-zinc-700 transition">Limpar</button>
      <button id="btnCopy" class="px-4 py-2 rounded-xl bg-emerald-600 text-white font-semibold hover:bg-emerald-500 transition disabled:opacity-40 disabled:cursor-not-allowed" disabled>Copiar</button>
      <span id="copyStatus" class="text-sm text-zinc-400"></span>
    </div>

    <section id="export" class="hidden bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4">
      <h3 class="font-semibold mb-2">Resumo em linha (para copiar)</h3>
      <div class="relative">
        <code id="exportLine" class="block w-full whitespace-pre-wrap break-words text-sm bg-zinc-950 border border-zinc-800 rounded-xl p-3"></code>
      </div>
      <p class="text-xs text-zinc-500 mt-2">
        Formato (5 colunas p/ Excel — Jogo, <em>BTTS Não</em>, <em>Over 2,5 Não</em>, <em>1 (Time A)</em>, Cantos Totais):
        <span class="font-mono">Time A x Time B 	(%) BTTS Não 	(%) Over 2,5 Não 	(%) Time A 	Total esperado: X.X</span>
      </p>
    </section>

    <section id="detected" class="hidden bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4">
      <h3 class="font-semibold mb-2">Placar(es) detectados (após normalização)</h3>
      <div id="detectedTables" class="grid md:grid-cols-2 gap-4"></div>
      <p class="text-xs text-zinc-400 mt-3">Inclui escanteios FT (se disponíveis) e resultado V/E/D.</p>
    </section>

    <section id="results" class="hidden grid md:grid-cols-2 gap-4">
      <div id="cardHome" class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4"></div>
      <div id="cardAway" class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4"></div>
    </section>

    <section id="wdlContext" class="hidden bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4">
      <h3 class="font-semibold">1X2 — médias simples (geral) + <span class="text-emerald-300">condição (últimos 5)</span></h3>
      <div id="wdlGrid" class="grid md:grid-cols-2 gap-4"></div>
      <p class="text-xs text-zinc-400 mt-3">Geral = todos os jogos fornecidos (mín. 10). Condição = <strong>últimos 5</strong> no mando correto (time A em casa, time B fora).</p>
    </section>

    <section id="decision" class="hidden bg-zinc-900/80 border border-zinc-700 rounded-2xl p-6 space-y-8">
      <div>
        <h3 class="text-xl font-bold mb-3">Ambos Marcam</h3>
        <div id="verdictLineBTTS" class="mb-2 text-sm text-zinc-300"></div>
      </div>

      <div class="border-t border-zinc-700 pt-6">
        <h3 class="text-xl font-bold mb-3">Mais 2.5</h3>
        <div id="verdictLineO25" class="mb-2 text-sm text-zinc-300"></div>
      </div>

      <div class="border-t border-zinc-700 pt-6">
        <h3 class="text-xl font-bold mb-3">Resultado (1X2)</h3>
        <div id="verdictLine1X2" class="mb-2 text-sm text-zinc-300"></div>
      </div>

      <div class="border-t border-zinc-700 pt-6">
        <h3 class="text-xl font-bold mb-3">Cantos — <span class="text-zinc-300">média FT</span></h3>
        <div id="verdictLineCantos" class="mb-2 text-sm text-zinc-300"></div>
      </div>
    </section>

    <footer class="pt-4 text-xs text-zinc-500">
      <p><strong>Observação:</strong> suporte estatístico amostral; não é conselho financeiro.</p>
    </footer>
  </div>

  <button id="btnTop" aria-label="Subir ao topo" title="Subir ao topo"
    class="fixed right-6 bottom-6 z-50 p-3 rounded-full bg-white text-black shadow-lg transition-transform duration-200 transform opacity-0 pointer-events-none focus:outline-none focus:ring-2 focus:ring-emerald-400">
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block align-middle">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  </button>

  <script>
    // ===== Utilidades & Seletores =====
    const $ = (id) => document.getElementById(id);
    const startsWithI = (s, k) => s.trim().toLowerCase().startsWith(k.toLowerCase());
    const isResultLetter = (s) => /^[VDE]$/i.test(s.trim());
    const bannedLines = ["Mostrar mais jogos", "Mostrar mais", "Show more", "Mostrar Menos Jogos"];

    let lastSummary = "";

    // ===== Cabeçalhos =====
    function splitSections_New(all){
      const lines = all.split(/\r?\n/);
      const idxs = [];
      for (let i=0;i<lines.length;i++){
        if (startsWithI(lines[i], "Jogos Anteriores:")) idxs.push({i, text: lines[i]});
      }
      const secc = { casa: [], fora: [] };
      if (!idxs.length) return secc;
      function sliceRange(start, end){ return lines.slice(start+1, end < 0 ? undefined : end); }
      if (idxs[0]){ const end = idxs[1] ? idxs[1].i : -1; secc.casa = sliceRange(idxs[0].i, end); }
      if (idxs[1]){ const end = -1; secc.fora = sliceRange(idxs[1].i, end); }
      return secc;
    }
    function extractTeamsFromHeaders_New(raw){
      const lines = raw.split(/\r?\n/);
      const rx = /^Jogos Anteriores:\s*(.+)$/i;
      const found = [];
      for (const line of lines){
        const m = line.match(rx);
        if (m && m[1].trim()){
          found.push(m[1].trim());
          if (found.length === 2) break;
        }
      }
      const [teamA, teamB] = [found[0] || 'Time A', found[1] || 'Time B'];
      return { teamA, teamB };
    }

    // ===== Parser novo (CornerPro) =====
    const rxTeamWithRank = /^(.*?)[\s\u00A0]*\(\d+\.º\)\s*$/;
    const rxNumNum = /^(\d{1,2})\s*\(\d{1,2}\)\s*$/;
    function isTeamLineWithRank(line){ return rxTeamWithRank.test((line||"").trim()); }
    function trimTeamRank(line){ const m=(line||"").trim().match(rxTeamWithRank); return (m?m[1]:(line||"")).trim(); }

    // Retorna lista em ordem do texto (assumido: mais recentes primeiro, como no site)
    function parseCornerProSection(lines){
      const L = lines.map(s => s.replace(/\t/g,' ').trim()).filter(s => s.length && !bannedLines.includes(s));
      const out = [];
      for (let i=0; i<L.length; i++){
        if (!isResultLetter(L[i])) continue;
        const res = L[i].toUpperCase();

        // duas linhas de time imediatamente acima do V/E/D (ordem preservada: 1º = mandante)
        const teamIdxs = [];
        for (let k=i-1; k>=0 && teamIdxs.length<2; k--){
          if (isTeamLineWithRank(L[k])) teamIdxs.unshift(k);
        }
        if (teamIdxs.length !== 2) continue;
        const homeTeam = trimTeamRank(L[teamIdxs[0]]);
        const awayTeam = trimTeamRank(L[teamIdxs[1]]);

        // métricas: gols H, gols A, cantos H, cantos A
        const n1 = L[i+1] || "", n2 = L[i+2] || "", n3 = L[i+3] || "", n4 = L[i+4] || "";
        const m1 = n1.match(rxNumNum), m2 = n2.match(rxNumNum), m3 = n3.match(rxNumNum), m4 = n4.match(rxNumNum);
        if (!m1 || !m2) continue;

        const gH = parseInt(m1[1],10), gA = parseInt(m2[1],10);
        const cH = m3 ? parseInt(m3[1],10) : null;
        const cA = m4 ? parseInt(m4[1],10) : null;

        out.push({
          text: `${homeTeam} ${gH} x ${gA} ${awayTeam} - ${res}` + (Number.isFinite(cH)&&Number.isFinite(cA) ? ` - (${cH} esc. casa - ${cA} esc. fora)` : ''),
          m: {homeTeam, awayTeam, gH, gA, res, cH, cA}
        });
      }
      return out; // [{text, m:{...}}]
    }

    // ===== Estatísticas =====
    function statsFrom(pairs){
      const n = pairs.length;
      if (n === 0) return {n:0, btts:0, pBTTS:NaN, over25:0, pO25:NaN, gpg:NaN, streakBTTS:0};
      let btts=0, over25=0, goals=0, streak=0;
      for (let i=0;i<n;i++){
        const [a,b] = pairs[i];
        const isBTTS = a>0 && b>0;
        const isO25  = (a+b) >= 3;
        if (isBTTS) btts++;
        if (isO25)  over25++;
        streak = i===0 ? (isBTTS?1:0) : (isBTTS?streak+1:0);
        goals += a+b;
      }
      return { n, btts, pBTTS: btts/n, over25, pO25: over25/n, gpg: goals/n, streakBTTS: streak };
    }
    function cornersStats(list){
      const n = list.length;
      if (!n) return {n:0, avgH:NaN, avgA:NaN, avgT:NaN};
      let sH=0, sA=0;
      for (const [h,a] of list){ sH+=h; sA+=a; }
      return { n, avgH: sH/n, avgA: sA/n, avgT: (sH+sA)/n };
    }
    function pct(n){ return isFinite(n) ? (n*100).toFixed(1) + '%' : '—'; }
    function pct0(n){ return isFinite(n) ? Math.round(n*100) + '%' : '—'; }
    function resBadge(res){
      const base = 'badge';
      if (res === 'V') return `<span class="${base} bg-emerald-900/60 text-emerald-100">V</span>`;
      if (res === 'E') return `<span class="${base} bg-amber-900/60 text-amber-100">E</span>`;
      if (res === 'D') return `<span class="${base} bg-rose-900/60 text-rose-100">D</span>`;
      return '<span class="text-zinc-400">—</span>';
    }

    function tableHTML(title, items){
      if (!items.length) return `<div class="text-zinc-500">Nenhum placar detectado.</div>`;
      const rows = items.map((it,i)=>{
        const [a,b, cH, cA, r] = it;
        return `<tr class="hover:bg-zinc-900/50">
          <td class="px-2 py-1 text-zinc-400">#${i+1}</td>
          <td class="px-2 py-1 font-mono">${a}-${b}</td>
          <td class="px-2 py-1 ${a>0&&b>0?'text-emerald-300':'text-zinc-300'}">${a>0&&b>0?'BTTS':'—'}</td>
          <td class="px-2 py-1 ${a+b>=3?'text-emerald-300':'text-zinc-300'}">${a+b>=3?'+2.5':'—'}</td>
          <td class="px-2 py-1 text-zinc-300">${a+b}</td>
          <td class="px-2 py-1 text-zinc-300">${(Number.isFinite(cH)&&Number.isFinite(cA)) ? (cH+'-'+cA) : '—'}</td>
          <td class="px-2 py-1">${resBadge(r)}</td>
        </tr>`;
      }).join('');
      return `
        <div>
          <h4 class="font-semibold mb-2">${title}</h4>
          <table class="w-full text-sm border border-zinc-800 rounded-xl overflow-hidden">
            <thead class="bg-zinc-900/60">
              <tr>
                <th class="px-2 py-1 text-left text-zinc-400">Jogo</th>
                <th class="px-2 py-1 text-left text-zinc-400">Placar</th>
                <th class="px-2 py-1 text-left text-zinc-400">Ambos?</th>
                <th class="px-2 py-1 text-left text-zinc-400">+2.5</th>
                <th class="px-2 py-1 text-left text-zinc-400">Gols</th>
                <th class="px-2 py-1 text-left text-zinc-400">Cantos</th>
                <th class="px-2 py-1 text-left text-zinc-400">Res.</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>`;
    }

    // Orienta um match para o ponto de vista do time informado
    function orientMatchForTeam(m, team){
      const isHome = (m.homeTeam === team);
      const teamGoals = isHome ? m.gH : m.gA;
      const oppGoals  = isHome ? m.gA : m.gH;
      const teamCorners = Number.isFinite(m.cH)&&Number.isFinite(m.cA) ? (isHome ? m.cH : m.cA) : NaN;
      const oppCorners  = Number.isFinite(m.cH)&&Number.isFinite(m.cA) ? (isHome ? m.cA : m.cH) : NaN;
      return [teamGoals, oppGoals, teamCorners, oppCorners, m.res || null];
    }

    // WDL a partir de uma seleção de objetos {m}
    function wdlFromSelForTeam(sel, team){
      const agg = { n: sel.length, w:0, d:0, l:0 };
      for (const obj of sel){
        const m = obj.m;
        const isHome = (m.homeTeam === team);
        const win  = isHome ? (m.gH > m.gA) : (m.gA > m.gH);
        const draw = (m.gH === m.gA);
        const loss = isHome ? (m.gH < m.gA) : (m.gA < m.gH);
        if (win) agg.w++; else if (draw) agg.d++; else if (loss) agg.l++;
      }
      return { n: agg.n, pW: agg.n ? agg.w/agg.n : NaN, pD: agg.n ? agg.d/agg.n : NaN, pL: agg.n ? agg.l/agg.n : NaN };
    }

    function analyze(){
      const raw = $("taUnified").value || "";
      const { teamA, teamB } = extractTeamsFromHeaders_New(raw);
      const secc = splitSections_New(raw);

      // Parse completo (com métricas e texto)
      const parsedHomeFull = parseCornerProSection(secc.casa); // [{text, m}]
      const parsedAwayFull = parseCornerProSection(secc.fora);

      // ===== USAR TODOS os jogos (mínimo 10 esperado, sem limite) =====
      const selHomeAll = parsedHomeFull;   // geral do time A
      const selAwayAll = parsedAwayFull;   // geral do time B

      // Tabelas (orientadas pelo time da própria seção)
      const scHome = selHomeAll.map(x => orientMatchForTeam(x.m, teamA));
      const scAway = selAwayAll.map(x => orientMatchForTeam(x.m, teamB));

      $("detected").classList.remove('hidden');
      $("detectedTables").innerHTML = [
        tableHTML(`${teamA} — placares detectados (geral · n=${scHome.length})`, scHome),
        tableHTML(`${teamB} — placares detectados (geral · n=${scAway.length})`, scAway),
      ].join('');

      // Estatísticas (médias simples) com todos os jogos disponíveis
      const stH = statsFrom(scHome.map(p=>[p[0],p[1]]));
      const stA = statsFrom(scAway.map(p=>[p[0],p[1]]));

      // Cantos (todos)
      function onlyFinite(x){ return Number.isFinite(x[0]) && Number.isFinite(x[1]); }
      const stHC = cornersStats(scHome.filter(x=>onlyFinite([x[2],x[3]])).map(x=>[x[2],x[3]]));
      const stAC = cornersStats(scAway.filter(x=>onlyFinite([x[2],x[3]])).map(x=>[x[2],x[3]]));

      // Cartões de resumo por time
      function cardHTML(label, st, stCorners, color){
        const warn = st.n < 10 ? '<div class="text-amber-300 text-xs">Mínimo recomendado: 10 jogos.</div>' : '';
        return `
          <div>
            <div class="flex items-center justify-between mb-2">
              <h3 class="font-semibold">${label}</h3>
              <span class="badge ${color}">n=${st.n}</span>
            </div>
            ${warn}
            <ul class="text-sm space-y-1">
              <li>BTTS: <span class="font-semibold">${pct(st.pBTTS)}</span> (${st.btts}/${st.n})</li>
              <li>Over 2.5: <span class="font-semibold">${pct(st.pO25)}</span> (${st.over25}/${st.n})</li>
              <li>Gols por jogo: <span class="font-semibold">${isFinite(st.gpg)?st.gpg.toFixed(2):'—'}</span></li>
              <li>Cantos médios (FT): <span class="font-semibold">${isFinite(stCorners.avgH)?stCorners.avgH.toFixed(1):'—'}</span> — <span class="font-semibold">${isFinite(stCorners.avgA)?stCorners.avgA.toFixed(1):'—'}</span> (tot: <span class="font-semibold">${isFinite(stCorners.avgT)?stCorners.avgT.toFixed(1):'—'}</span>)</li>
            </ul>
          </div>`;
      }

      $("results").classList.remove('hidden');
      $("cardHome").innerHTML = cardHTML(`${teamA} (geral · n=${stH.n})`, stH, stHC, 'bg-emerald-900/40 text-emerald-100');
      $("cardAway").innerHTML = cardHTML(`${teamB} (geral · n=${stA.n})`, stA, stAC, 'bg-sky-900/40 text-sky-100');

      // 1) 1X2 — MÉDIAS GERAIS (todos os jogos) [mantido p/ contexto]
      const WDL_A_general = wdlFromSelForTeam(selHomeAll, teamA);
      const WDL_B_general = wdlFromSelForTeam(selAwayAll, teamB);

      // 2) 1X2 — CONDIÇÃO (ÚLTIMOS 5 no mando correto)
      const selA_home5 = selHomeAll.filter(obj => obj.m.homeTeam === teamA).slice(0,5);
      const selB_away5 = selAwayAll.filter(obj => obj.m.awayTeam === teamB).slice(0,5);
      const WDL_A_home5 = wdlFromSelForTeam(selA_home5, teamA);
      const WDL_B_away5 = wdlFromSelForTeam(selB_away5, teamB);

      $("wdlContext").classList.remove('hidden');
      $("wdlGrid").innerHTML = `
        <div class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-3">
          <div class="flex items-center justify-between mb-1">
            <h4 class="font-semibold text-sm">${teamA}</h4>
            <span class="badge bg-zinc-800 text-zinc-200">geral n=${WDL_A_general.n}</span>
          </div>
          ${WDL_A_general.n<10?'<div class="text-amber-300 text-xs">Mínimo recomendado: 10 jogos gerais.</div>':''}
          <div class="text-xs grid grid-cols-3 gap-2 mb-3">
            <div><div class="text-zinc-400">Vitórias</div><div class="font-semibold">${pct(WDL_A_general.pW)}</div></div>
            <div><div class="text-zinc-400">Empates</div><div class="font-semibold">${pct(WDL_A_general.pD)}</div></div>
            <div><div class="text-zinc-400">Derrotas</div><div class="font-semibold">${pct(WDL_A_general.pL)}</div></div>
          </div>
          <div class="border-t border-zinc-800 pt-2 mt-2">
            <div class="flex items-center justify-between mb-1">
              <div class="text-xs text-zinc-400">Em casa (últimos 5)</div>
              <span class="badge bg-emerald-900/30 text-emerald-100">n=${WDL_A_home5.n}</span>
            </div>
            <div class="text-[11px] grid grid-cols-3 gap-2">
              <div><div class="text-zinc-500">Vitórias</div><div class="font-semibold">${pct(WDL_A_home5.pW)}</div></div>
              <div><div class="text-zinc-500">Empates</div><div class="font-semibold">${pct(WDL_A_home5.pD)}</div></div>
              <div><div class="text-zinc-500">Derrotas</div><div class="font-semibold">${pct(WDL_A_home5.pL)}</div></div>
            </div>
          </div>
        </div>

        <div class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-3">
          <div class="flex items-center justify-between mb-1">
            <h4 class="font-semibold text-sm">${teamB}</h4>
            <span class="badge bg-zinc-800 text-zinc-200">geral n=${WDL_B_general.n}</span>
          </div>
          ${WDL_B_general.n<10?'<div class="text-amber-300 text-xs">Mínimo recomendado: 10 jogos gerais.</div>':''}
          <div class="text-xs grid grid-cols-3 gap-2 mb-3">
            <div><div class="text-zinc-400">Vitórias</div><div class="font-semibold">${pct(WDL_B_general.pW)}</div></div>
            <div><div class="text-zinc-400">Empates</div><div class="font-semibold">${pct(WDL_B_general.pD)}</div></div>
            <div><div class="text-zinc-400">Derrotas</div><div class="font-semibold">${pct(WDL_B_general.pL)}</div></div>
          </div>
          <div class="border-t border-zinc-800 pt-2 mt-2">
            <div class="flex items-center justify-between mb-1">
              <div class="text-xs text-zinc-400">Fora (últimos 5)</div>
              <span class="badge bg-sky-900/30 text-sky-100">n=${WDL_B_away5.n}</span>
            </div>
            <div class="text-[11px] grid grid-cols-3 gap-2">
              <div><div class="text-zinc-500">Vitórias</div><div class="font-semibold">${pct(WDL_B_away5.pW)}</div></div>
              <div><div class="text-zinc-500">Empates</div><div class="font-semibold">${pct(WDL_B_away5.pD)}</div></div>
              <div><div class="text-zinc-500">Derrotas</div><div class="font-semibold">${pct(WDL_B_away5.pL)}</div></div>
            </div>
          </div>
        </div>`;

      // ======== ESTRATÉGIA TIPSTER (últimos 5 no mando correto) ========
      function bttsOverFromSample(sel){
        let n = sel.length, cBTTS = 0, cO25 = 0;
        for (const o of sel){
          const a = o.m.gH, b = o.m.gA;
          if ((a>0)&&(b>0)) cBTTS++;
          if ((a+b)>=3) cO25++;
        }
        return {
          n,
          pBTTS: n? cBTTS/n : NaN,
          countBTTS: cBTTS,
          pO25: n? cO25/n : NaN,
          countO25: cO25
        };
      }
      const tip_A = bttsOverFromSample(selA_home5); // A em casa
      const tip_B = bttsOverFromSample(selB_away5); // B fora

      const pBTTS5 = ( (isFinite(tip_A.pBTTS)?tip_A.pBTTS:0) + (isFinite(tip_B.pBTTS)?tip_B.pBTTS:0) ) / 2 || NaN;
      const pO25_5  = ( (isFinite(tip_A.pO25)?tip_A.pO25:0)   + (isFinite(tip_B.pO25)?tip_B.pO25:0) ) / 2 || NaN;

      const pHome5 = ( (isFinite(WDL_A_home5.pW)?WDL_A_home5.pW:0) + (isFinite(WDL_B_away5.pL)?WDL_B_away5.pL:0) ) / 2 || NaN;
      const pDraw5 = ( (isFinite(WDL_A_home5.pD)?WDL_A_home5.pD:0) + (isFinite(WDL_B_away5.pD)?WDL_B_away5.pD:0) ) / 2 || NaN;
      const pAway5 = ( (isFinite(WDL_A_home5.pL)?WDL_A_home5.pL:0) + (isFinite(WDL_B_away5.pW)?WDL_B_away5.pW:0) ) / 2 || NaN;

      function avgCornersTeamFrom(sel, side){
        const vals = sel
          .map(o => side==='home' ? o.m.cH : o.m.cA)
          .filter(v => Number.isFinite(v));
        if (!vals.length) return NaN;
        const sum = vals.reduce((a,b)=>a+b,0);
        const denom = Math.min(5, vals.length) || vals.length;
        return sum / denom;
      }
      const meanCornersA5 = avgCornersTeamFrom(selA_home5, 'home');
      const meanCornersB5 = avgCornersTeamFrom(selB_away5, 'away');
      const meanCornersTotal5 = (isFinite(meanCornersA5)?meanCornersA5:0) + (isFinite(meanCornersB5)?meanCornersB5:0);
      const cornersReady = isFinite(meanCornersA5) && isFinite(meanCornersB5);

      const TH = 0.55;

      // ===== Render decisório com destaques e (x/5 jogos) =====
      $("decision").classList.remove('hidden');

      // Ambos
      const bttsYes = isFinite(pBTTS5) && pBTTS5 >= TH;
      const bttsBadge = bttsYes
        ? `<span class="badge bg-emerald-600 text-white">Sim</span>`
        : `<span class="badge bg-rose-600 text-white">Não</span>`;
      $("verdictLineBTTS").innerHTML = `
        <div class="flex flex-col gap-2">
          <div class="flex flex-wrap items-center gap-3">
            <span class="badge bg-zinc-800 text-zinc-100">Ambas</span>
            ${bttsBadge}
            <span>p≈ <strong>${pct(pBTTS5)}</strong></span>
          </div>
          <div class="text-xs flex flex-wrap gap-4 text-zinc-400">
            <span>${teamA} (casa): <strong>${tip_A.countBTTS}/${tip_A.n}</strong> jogos • ${pct(tip_A.pBTTS)}</span>
            <span>${teamB} (fora): <strong>${tip_B.countBTTS}/${tip_B.n}</strong> jogos • ${pct(tip_B.pBTTS)}</span>
          </div>
        </div>`;

      // Over 2.5
      const overYes = isFinite(pO25_5) && pO25_5 >= TH;
      const overBadge = overYes
        ? `<span class="badge bg-emerald-600 text-white">Sim</span>`
        : `<span class="badge bg-rose-600 text-white">Não</span>`;
      $("verdictLineO25").innerHTML = `
        <div class="flex flex-col gap-2">
          <div class="flex flex-wrap items-center gap-3">
            <span class="badge bg-zinc-800 text-zinc-100">Over 2,5</span>
            ${overBadge}
            <span>p≈ <strong>${pct(pO25_5)}</strong></span>
          </div>
          <div class="text-xs flex flex-wrap gap-4 text-zinc-400">
            <span>${teamA} (casa): <strong>${tip_A.countO25}/${tip_A.n}</strong> jogos • ${pct(tip_A.pO25)}</span>
            <span>${teamB} (fora): <strong>${tip_B.countO25}/${tip_B.n}</strong> jogos • ${pct(tip_B.pO25)}</span>
          </div>
        </div>`;

      // 1X2 — cores e barra
      const opts1x2 = [
        { k: 'Casa',   p: pHome5,  key: teamA, color: 'bg-emerald-600 text-white' },
        { k: 'Empate', p: pDraw5,  key: 'Empate', color: 'bg-amber-600 text-black' },
        { k: 'Fora',   p: pAway5,  key: teamB, color: 'bg-sky-600 text-white' }
      ].sort((a,b)=> (isFinite(b.p)-isFinite(a.p)) || (b.p-a.p));
      const topPick = opts1x2[0];
      const homePct = isFinite(pHome5)?Math.round(pHome5*100):0;
      const drawPct = isFinite(pDraw5)?Math.round(pDraw5*100):0;
      const awayPct = isFinite(pAway5)?Math.round(pAway5*100):0;

      $("verdictLine1X2").innerHTML = `
        <div class="flex flex-col gap-2">
          <div class="flex items-center gap-3">
            <span class="badge bg-zinc-800 text-zinc-100">Resultado</span>
            <span class="badge ${topPick.color}">${topPick.k}</span>
            <span>p≈ <strong>${pct(topPick.p)}</strong></span>
          </div>
          <div class="meter">
            <div class="bg-emerald-600" style="width:${homePct}%"></div>
            <div class="bg-amber-600"  style="width:${drawPct}%"></div>
            <div class="bg-sky-600"    style="width:${awayPct}%"></div>
          </div>
          <div class="flex flex-wrap gap-3 text-sm">
            <span>${teamA} (Casa): <strong>${pct(pHome5)}</strong></span>
            <span>Empate: <strong>${pct(pDraw5)}</strong></span>
            <span>${teamB} (Fora): <strong>${pct(pAway5)}</strong></span>
          </div>
        </div>`;

      // Cantos — destaque amarelo no total esperado
      $("verdictLineCantos").innerHTML = `
        <div class="flex flex-wrap items-center gap-3">
          <span class="badge bg-zinc-800 text-zinc-100">Escanteios (média FT)</span>
          <span>${teamA} (casa): <strong>${isFinite(meanCornersA5)?meanCornersA5.toFixed(1):'—'}</strong></span>
          <span>${teamB} (fora): <strong>${isFinite(meanCornersB5)?meanCornersB5.toFixed(1):'—'}</strong></span>
          <span class="badge bg-amber-700/60 text-amber-100">Total esperado: <strong>${cornersReady?meanCornersTotal5.toFixed(1):'—'}</strong></span>
        </div>`;

      // ===== Resumo em linha (NOVO FORMATO: (%) BTTS Não | (%) Over 2,5 Não | (%) Time A) =====
      const pBTTS_no = isFinite(pBTTS5) ? (1 - pBTTS5) : NaN;
      const pO25_no  = isFinite(pO25_5) ? (1 - pO25_5) : NaN;

      const col1 = `${teamA} x ${teamB}`;
      const col2 = `(${pct0(pBTTS_no)}) BTTS Não`;
      const col3 = `(${pct0(pO25_no)}) Over 2,5 Não`;
      const col4 = `(${pct0(pHome5)}) ${teamA}`;
      const col5 = `Total esperado: ${cornersReady?meanCornersTotal5.toFixed(1):'—'}`;

      // Linha para copiar (com TABs)
      const line = `${col1}\t${col2}\t${col3}\t${col4}\t${col5}`;
      lastSummary = line;

      // Exibição amigável (com 4 espaços)
      $("exportLine").textContent = `${col1}    ${col2}    ${col3}    ${col4}    ${col5}`;
      $("export").classList.remove('hidden');
      $("btnCopy").disabled = false;
      $("copyStatus").textContent = '';
    }

    $("btnAnalyze").addEventListener('click', analyze);

    $("btnClear").addEventListener('click', () => {
      $("taUnified").value = '';
      ["results","decision","detected","export","wdlContext"].forEach(id=>$(id).classList.add('hidden'));
      $("detectedTables").innerHTML = '';
      ["cardHome","cardAway","verdictLineBTTS","verdictLineO25","exportLine","verdictLine1X2","verdictLineCantos","wdlGrid"].forEach(id=>{ const el = $(id); if (el) el.textContent = ''; });
      $("btnCopy").disabled = true;
      $("copyStatus").textContent = '';
      lastSummary = '';
    });

    // ===== Botão Copiar (corrigido) =====
    $("btnCopy").addEventListener('click', async () => {
      if (!lastSummary) return;
      try {
        await navigator.clipboard.writeText(lastSummary);
        $("copyStatus").textContent = 'Copiado!';
      } catch (e) {
        // Fallback
        const ta = document.createElement('textarea');
        ta.value = lastSummary;
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.select();
        try {
          document.execCommand('copy');
          $("copyStatus").textContent = 'Copiado!';
        } catch (err) {
          $("copyStatus").textContent = 'Falha ao copiar';
        } finally {
          document.body.removeChild(ta);
        }
      }
      setTimeout(()=>{$("copyStatus").textContent='';}, 2000);
    });

    (function setupScrollTop(){
      const btn = $("btnTop");
      if (!btn) return;
      const showAfter = 250;
      function onScroll(){
        if (window.scrollY > showAfter){
          btn.classList.remove('opacity-0','pointer-events-none','scale-95');
          btn.classList.add('opacity-100','scale-100');
        } else {
          btn.classList.add('opacity-0','pointer-events-none','scale-95');
          btn.classList.remove('opacity-100','scale-100');
        }
      }
      btn.classList.add('opacity-0','pointer-events-none','scale-95');
      btn.classList.remove('opacity-100');
      window.addEventListener('scroll', onScroll, {passive:true});
      btn.addEventListener('click', function(e){ e.preventDefault(); window.scrollTo({ top: 0, behavior: 'smooth' }); });
      btn.addEventListener('focus', () => { btn.classList.remove('opacity-0','pointer-events-none','scale-95'); btn.classList.add('opacity-100'); });
      btn.addEventListener('blur', onScroll);
    })();
  </script>
</body>
</html>
